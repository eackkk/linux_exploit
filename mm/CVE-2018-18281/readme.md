*原文：https://googleprojectzero.blogspot.com/2019/01/taking-page-from-kernels-book-tlb-issue.html*

*参考：https://www.iceswordlab.com/2019/03/08/cve-2018-18281/*

### TLB

### race 技巧：抢占和CPU优先级

linux内核支持三种不同的抢占模型，必须在build时选择一种：

- CONFIG_PREEMPT_NONE(无强迫抢占(服务器))
- CONFIG_PREEMPT_VOLUNTARY(自愿内核抢占(桌面))
- CONFIG_PREEMPT(内核可抢占(低延迟桌面))

其中，Pixel 6 和 Huawei Mate50 pro 的内核配置都设置为 CONFIG_PREEMPT：

![image](https://github.com/eackkk/linux_exploit/assets/73926435/2df701e1-b281-4f3d-ac9e-253a0841375b)

这意味着，内核代码可以在执行期间的任何时候被中断，甚至包括进程持有互斥锁、信号量和它位于RCU读端临界区时(取决于内核配置)。只有像自旋锁这样的东西才能抑制抢占。

因此，当内核存在一个race漏洞时，可以将指定进程踢出当前的CPU核，让进程远离CPU一段时间，从而扩大被race的时间窗口，linux内核提供了操作调度的相关API：

- sched_setaffinity：设置进程在哪个或者哪几个CPU核心上运行，使用方法如下：

  ![image](https://github.com/eackkk/linux_exploit/assets/73926435/ec5b93e0-8e6b-4b62-b63b-11018cd2f3c8)

- sched_setscheduler：为指定的pid设置调度策略policy和参数param，使用方法如下：

  ![image](https://github.com/eackkk/linux_exploit/assets/73926435/082cf6a7-de11-455e-a1a5-fffb4bf1c78d)

  linux中的policy分为普通调度策略(normal scheduling policies)和实时调度策略(real time scheduling policies)：

  - SCHED_NORMAL和SCHED_BATCH调度普通的非实时进程
  - SCHED_FIFO和SCHED_RR和SCHED_DEADLINE则采用不同的调度策略调度实时进程
  - SCHED_IDLE则在系统空闲时调用idle进程




